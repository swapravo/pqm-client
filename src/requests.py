from getpass import getpass

import src.globals
import src.utils
import src.crypto
import src.network
import src.db


def username_availability_check():

	"""
	request = -> This is serialised and sent over to the server	{

		"version": string, src.globals.VERSION

		"token": {
			"type": "hash", string
			"token": bytes, hash of request["request"], NOT signed
			}

		"request": -> This serialised and asymmetrically encrypted with the server's keys	{
			"timestamp": integer, an unix timestamp # 1
			"nonce": bytes, of length src.globals.HASH_SIZE # 2
			"request_code": src.globals.USERNAME_AVAILABILITY_CHECK

			"request": {
				"username": string
				"rolling_public_key": bytes, an encryption key, generated by the client to recieve the response
				}
			}
		}

	1. Timestamp:
		To prevent attackers from replaying valid but old messages.
		If the difference between this timestamp and the server's
		internal time is more than a threshold, the message will be discarded.

	2. nonce:
		To be replayed by the server to prevent
		cross-request forgeries and replay attacks.
		Proves that it has the private keys
		to the public keys of what the client
		application says is the legitimate server.
		Also Prevents an attacker from trivially
		guessing the username by comparing the hash
		in case of an username availability check.

	"""

	out, err = None, None

	# create a keyring and insert the server's public keys
	keys, err = src.db.fetch_server_keys()
	if err:
		print("Failed to fetch server keys!")
		return (out, err)

	src.crypto.insert_public_key(keys[0], src.crypto.encryption_key(src.globals.SERVER))
	src.crypto.insert_public_key(keys[1], src.crypto.signature_key(src.globals.SERVER))
	del keys

	while True:

		username = "user" #input('Username: ')

		if username == 'quit':
			return (None, 0)

		if not src.utils.username_is_vailid(username):
			continue

		if src.crypto.key_exists_in_keyring(username):
			print("A key with that name already exists in the keyring! Try another username.")
			continue

		if src.utils.issqlite3(username):
			print("Username already exists in keyring / database! Try another username.")
			continue

		rolling_public_key_name = src.utils.random_name_generator()
		out, err = src.crypto.generate_encryption_keys(rolling_public_key_name)
		if err:
			print("FAILED to generate encryption keys!")
			return (None, 1)

		if src.globals.VERBOSE:
			print("Rolling public keys generated.")

		nonce = src.crypto.nonce()

		out, err = src.crypto.fetch_public_keys(rolling_public_key_name)
		if err:
			return (None, 1)

		request = {
			"timestamp": src.utils.timestamp(), \
		 	"nonce": nonce, \
			"request_code": src.globals.USERNAME_AVAILABILITY_CHECK, \
			"request": { \
				"username": username, \
				"rolling_public_key": out}}

		if src.globals.VERBOSE:
			print("Rolling public keys fetched.")

		request, err = src.crypto.asymmetrically_encrypt(src.utils.pack(request), \
			src.crypto.encryption_key(src.globals.SERVER))

		if err:
			return (None, 1)

		request = src.utils.pack({
			"version": src.globals.VERSION,
			"token": {
				"type": src.globals.HASH,
				"token": src.crypto.hash(request)},
			"request": request})

		request = src.utils.sizeof(request) + request

		try:
			src.network.send(request)
			if src.globals.VERBOSE:
				print("Username availability request sent.")

			response = src.network.recieve(src.globals.SMALL_RESPONSE)
			if src.globals.VERBOSE:
				print("Username availability response recieved.")

		except:
			if src.globals.VERBOSE:
				print("Username availability request FAILED!")
			return

		del request

		"""
		response = {

			"token": {
				"type": string "hash", this response is NOT signed (for now)
					as only a limited number of messages can be signed
					with a single key and keys are hard to generate

				"token": bytes, hash of response["response"]
				}

			"response": -> serialised and asymmetrically encrypted with the key that was sent to the server
				{
				"nonce": the same nonce that was sent to the server by the client
				"response": src.globals.USERNAME_FOUND or src.globals.USERNAME_NOT_FOUND
				}
			}

		"""

		if not response:
			print("Server closed the connection.")
			return (None, 0)

		response = src.utils.unpack(response)

		if not response:
			return (None, 0)

		# try except for keyerror
		if response["token"]["type"] != src.globals.HASH:
			print("INVALID Message token!")
			return (None, 1)

		if response["token"]["token"] != src.crypto.hash(response["response"]):
			print("Hash verification for the message FAILED!")
			return (None, 1)

		response, err = src.crypto.validate_asymmetric_response(response["response"], nonce)

		if err:
			print("Invalid response recieved!")
			return (None, 1)

		if response["response"] == src.globals.USERNAME_NOT_FOUND:
			return (username, src.globals.USERNAME_NOT_FOUND)

		elif response["response"] == src.globals.USERNAME_FOUND:
			return (username, src.globals.USERNAME_FOUND)

		else:
			print("Recieved invalid response from server. Please retry:")
			return (None, 1)


def signup():

	"""
	STRUCTURE OF THE REQUEST
	request = -> This is serialised and sent over to the server	{

		"version": string,

		"token": {
			"type": "hash", string
			"token": bytes, hash of request["request"], NOT signed
			}

		"request": -> This serialised and asymmetrically encrypted with the server's keys	{
			"timestamp": integer, an unix timestamp
			"nonce": bytes, of length src.globals.HASH_SIZE
			"request_code": src.globals.SIGNUP_REQUEST

			"request": {
				"username": string
				"encryption_public_key": bytes, this key will be linked to this username from now
				"signature_public_key": bytes, this key will be linked to this username from now
				}
			}
		}

	STRUCTURE OF THE RESPONSE
	response = -> This is serialised and sent over to the client	{

		"token": {
			"type": "sign", string
			"token": bytes, signature of the hash of request["request"]
			}

		"response": -> This serialised and asymmetrically encrypted with the client's keys	{
			"nonce": bytes, of length src.globals.HASH_SIZE # 2
			"response": src.globals.SIGNUP_SUCCESSFUL or src.globals.SIGNUP_UNSUCCESSFUL
			}
		}
	"""

	out, err = None, None

	print("\nSignup:")
	print("Type quit to leave.\n")

	while True:
		username, response = username_availability_check()
		if response == src.globals.USERNAME_NOT_FOUND:
			break
		choice = input("Try again ? ")
		if choice.lower() != "y" or choice.lower() != "yes":
			return (None, 0)

	while True:
		password = "a" # getpass()
		if password == "quit":
			return (None, 0)
		if src.utils.password_is_strong(password):
			break

	password = bytes(password, 'utf-8')

	out, err = src.crypto.generate_encryption_keys(src.crypto.encryption_key(username))
	if err:
		return

	# sig keys have already been generated
	# out, err = src.crypto.generate_signature_keys(crypto.signature_key(username))
	# if err:
	#	return

	nonce = src.crypto.nonce()

	request = {
		"timestamp": src.utils.timestamp(), \
		"nonce": nonce, \
		"request_code": src.globals.SIGNUP, \
		"request": { \
			"username": username, \
			"encryption_public_key": None, \
			"signature_public_key": None}
			}

	out, err = src.crypto.fetch_public_keys(src.crypto.encryption_key(username))

	if err:
		return
	else:
		request["request"]["encryption_public_key"] = out

	out, err = src.crypto.fetch_public_keys(src.crypto.signature_key(username))

	if err:
		return
	else:
		request["request"]["signature_public_key"] = out

	request, err = src.crypto.asymmetrically_encrypt(src.utils.pack(request), \
		src.crypto.encryption_key(src.globals.SERVER))

	if err:
		return

	request = src.utils.pack({
		"version": src.globals.VERSION,
		"token": {
			"type": src.globals.HASH,
			"token": src.crypto.hash(request)},
		"request": request})

	request = src.utils.sizeof(request) + request

	try:
		src.network.send(request)
		if src.globals.VERBOSE:
			print("Signup request sent!")

		response = src.network.recieve(src.globals.SMALL_RESPONSE)
		if src.globals.VERBOSE:
			print("Signup response recieved!")

	except:
		print("Network Error!")
		return

	del request

	if not response:
		print("Server closed the connection.")
		return

	response = src.utils.unpack(response)
	#print("decoded response: ", response)

	if not response:
		return

	# try excepts for keyerrors
	if response["token"]["type"] != src.globals.SIGN:
		print("INVALID Message token!")
		return

	out, err = src.crypto.verify_signature(response["token"]["token"])
	if err:
		return
	if out != src.crypto.hash(response["response"]):
		print("INVALID Message token!")
		return

	else:
		response = response["response"]

	response, err = src.crypto.validate_asymmetric_response(response, nonce)
	if err:
		return

	if response["response"] == src.globals.SIGNUP_SUCCESSFUL:
		# sync with DB now
		out, err = src.db.add_user(username, password)
		if err:
			print("Signup FAILED!\n\n")
			return
			# shred and remove .ccr now
	else:
		print("Recieved invalid response from server. Please retry:")
		return

		# tell them about our pricing
		# The computation costs to create a signing key
		# will probably prevent bots from spamming. Do something
		# to prevent people from creating multiple accounts
		# without paying up :/


def login():

	"""
	As a later feature, the
	user will get to choose whether he wants to send his
	(symmetric and asymmetric) keys encrypted with his
	symmetric password over to our server.
	The default option provides the user more freedom over his keys
	at the cost of portability. (he will still be allowed to manually
	export his keys to portable storage devices of his choice like before)
	If the user chooses the latter,
	we shall need a method to establish that he will be able to decrypt
	the encrypted passwords we are holding for him.

	first check whether the user exists on this computer or not.
	if it does, decrypt, connect to the server to authenticate & synchronise
	else, check whether the user exists on the server and
	authenticate and sync him.
	"""

	# client-side login
	print("Login:")
	print("Type quit to leave.")
	while True:
		username = input('username: ')
		if username == "quit":
			return
		password = getpass()
		if password == "quit":
			return
		if not src.utils.username_is_vailid(username):
			continue
		response = src.db.authenticate_user(username, password)
		if response:
			src.globals.USERNAME = username
			src.globals.PASSWORD = password
			# after server side login
			print("Client-side Login Successful.")
			break

	nonce = src.crypto.nonce()
	message = {
		"timestamp": src.utils.timestamp(), \
		"nonce": nonce, \
		"request_code": src.globals.LOGIN_STEP_1, \
		"username": src.globals.USERNAME}

	request = src.crypto.asymmetrically_encrypt(src.utils.pack(message), \
		src.crypto.encryption_key(src.globals.SERVER))

	del message

	sign =  src.crypto.sign(src.crypto.hash(request), src.globals.SERVER)
	request = src.globals.SIGNATURE_DENOTER + src.utils.sizeof(sign) + sign + request
	request = src.globals.VERSION + src.utils.sizeof(request) + request

	src.network.send(request)
	try:
		response = memoryview(src.network.recieve(src.globals.SMALL_RESPONSE)) #NO NOT USERNAME AVAIL
	except TypeError:
		return

	del request

	if response == b'':
		print("Server closed the connection.")
		return

	recieved_hash = response[:src.globals.HASH_SIZE]
	if recieved_hash != src.crypto.hash(response[src.globals.HASH_SIZE:]):
		print("Hash verification FAILED!. Please retry!")
		return
	else:
		response = response[src.globals.HASH_SIZE:]

	message = src.utils.validate_asymmetric_response(response, nonce)
	if message == 1:
		return

	if message["response_code"] != src.globals.OKAY:
		print("Login FAILED! Please retry!")
		return
	else:
		key = src.crypto.symmetric_key_generator()

		message = {
			"timestamp": src.utils.timestamp(), \
			"request_code:": src.globals.LOGIN_STEP_2, \
			"nonce": message["nonce2"], \
			"symmetric_key": key}

	request = src.crypto.asymmetrically_encrypt(src.utils.pack(message), \
		src.crypto.encryption_key(src.globals.SERVER))
	del request

	signature = src.crypto.sign(src.crypto.hash(request), src.globals.SERVER)
	if signature == 1:
		return

	request = src.globals.SIGNATURE_DENOTER + src.utils.sizeof(signature) + request

	request = src.globals.VERSION + src.utils.sizeof(request) + request

	del message, signature

	try:
		src.network.send(request)
		response = memoryview(src.network.recieve(src.globals.RESPONSE_SIZE))
	except TypeError:
		# some error message
		return

	del request

	if response == b'':
		print("Server closed the connection.")
		return

	# VERIFY SIGNATURE HERE

	message = src.utils.validate_asymmetric_response(response)
	if message:
		return

	src.globals.ROLLING_ID = message["rolling_id"]
	src.globals.ROLLING_AUTHENTICATION_TOKEN = message["rolling_authentication_token"]
	src.globals.KEY = key
	print("Server-side login SUCCESSFULL!")
	del message
